#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
pls_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls\n\n"
    printf "  Project Level Shortcuts (pls) is a command-line tool designed to streamline \n  your workflow by allowing you to create, manage, and execute custom aliases \n  for frequently used commands.\n  \n  Key features:\n   * Easy alias creation and modification\n        Add, remove, rename, or change functionality of aliases with a simple\n        CLI interface.\n   * Project Level Specificity \n        Aliases can be defined at both project and global levels, with\n        project-specific aliases taking precedence.\n   * Intuitive command execution:\n        Run a command associated with an alias using the 'pls' prefix.\n        e.g. pls open, pls test, pls deploy\n   * Easily shareable aliases:\n        Streamline your team's workflow by sharing aliases across projects, or\n        make setup of your product dead-easy for your users.\n        Just add a pls file to the project's root directory, and you're off!\n  \n  To see examples of how to use pls, run 'pls <command> --help'\n\n"
  else
    printf "pls - Project Level Shortcuts (pls) is a command-line tool designed to streamline \n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  pls [COMMAND]\n"
  printf "  pls [COMMAND] --help | -h\n"
  printf "  pls --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Execute the command associated with given ALIAS. (default)\n" "execute_alias"
  printf "  %s   Add or alter a new alias in the current directory.\n" "add_alias    "
  printf "  %s   Remove an alias from the desired directory.\n" "delete_alias "
  printf "  %s   List all aliases available for invocation in the current directory.\n" "list_aliases "
  printf "  %s   Pick an alias from the list of available aliases to execute.\n" "pick_alias   "
  printf "  %s   Clear the cache of all commands that have been run with pls.\n" "clear_cache  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PLS_FILENAME"
    printf "    The name of the data file in which your aliases live. It is not recommended\n    to change this value for consistency sake, but you can if you feel the need\n    to do so.\n"
    printf "    Default: .pls.yml\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PLS_GLOBAL"
    printf "    The path to the global pls file (contains aliases that are available in all\n    directories). Default is determined by '\$HOME/\$PLS_FILENAME'.\n"
    printf "    Default: $(echo $HOME/$PLS_FILENAME)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PLS_DIR"
    printf "    The path to the directory used by pls for storing internal files, such as\n    the command cache. It is not recommended to set this to a directory in\n    /tmp/, as this may break caching across reboots. Default is determined by\n    '\$HOME/.local/share/pls'.\n"
    printf "    Default: $(echo $HOME/.local/share/pls)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PLS_ENABLE_CACHE_CHECK"
    printf "    Enable or disable cache checking, which prevents you from unexpectedly\n    running the wrong command. Setting this to false turns off the verification\n    warning that appears when you run an uncached command.\n    This is not recommended, especially not on sensitive systems. This setting\n    is overridden by 'pls_always_cache_check'.\n"
    printf "    Default: true\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PLS_ALWAYS_VERIFY"
    printf "    This will always prompt you to confirm every command before running it, even\n    if it is already cached. Does not assure that the command is safe, but does\n    give you a chance to review it. This setting overrides\n    'pls_enable_cache_check'.\n"
    printf "    Default: false\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PLS_ENABLE_FZF"
    printf "    Enable or disable the use of fzf for interactive selection. Note that this\n    is only relevant for the 'pick_alias' command. If fzf is not installed, this\n    will have no effect.\n"
    printf "    Default: true\n"
    echo

  fi
}

# :command.usage
pls_execute_alias_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls execute_alias\n\n"
    printf "  Execute the command associated with given ALIAS.\n\n"
  else
    printf "pls execute_alias - Execute the command associated with given ALIAS.\n\n"
  fi
  printf "Alias: e\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pls [execute_alias] [ALIAS] [COMMAND_ARGS...]\n"
  printf "  pls execute_alias --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ALIAS"
    printf "    The alias to execute.\n"
    echo

    # :argument.usage
    printf "  %s\n" "COMMAND_ARGS..."
    printf "    Arguments to pass to the command.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls execute_alias build\n    Executes the command associated with the alias 'build'.\n  pls e test\n    Executes the command associated with the alias 'test'.\n"
    printf "  pls deploy\n    Executes the command associated with the alias 'deploy'.\n"
    printf "  pls\n    Launches an interactive prompt to select an alias to execute.\n"
    echo

  fi
}

# :command.usage
pls_add_alias_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls add_alias\n\n"
    printf "  Add or alter a new alias in the current directory.\n\n"
  else
    printf "pls add_alias - Add or alter a new alias in the current directory.\n\n"
  fi
  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pls add_alias [OPTIONS]\n"
  printf "  pls add_alias --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--alias, -a ALIAS (required)"
    printf "    The name of the alias to add.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--command, -c COMMAND (required)"
    printf "    The command to associate with the alias.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite the alias if it already exists.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--destination, -d DESTINATION (required)"
    printf "    Add the alias to the pls file for the desired context. (g)lobal, (l)ocal, or\n    (h)ere. ('here' means 'use the CWD, even if a local file exists')\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls add_alias -a build -c 'npm run build' -d l\n    Adds an alias 'build' that runs a single-line command to the local pls file.\n"
    printf "  pls a -a test -c 'echo hello\necho world!' -d g\n    Adds an alias 'hello' that runs a multi-line command to the global pls file.\n"
    printf "  pls a -a my_name -c 'echo \"My name is $1\"' -d h\n    Adds an alias 'foo' that runs a parameterized command and stores it in the\n  pls file in the current directory. The command can be run with 'pls my_name\n  <name>'.\n"
    echo

  fi
}

# :command.usage
pls_delete_alias_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls delete_alias\n\n"
    printf "  Remove an alias from the desired directory.\n\n"
  else
    printf "pls delete_alias - Remove an alias from the desired directory.\n\n"
  fi
  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pls delete_alias [OPTIONS]\n"
  printf "  pls delete_alias --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--alias, -a ALIAS (required)"
    printf "    The name of the alias to remove.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--destination, -d DESTINATION (required)"
    printf "    Remove the alias from the pls file for the desired context. (g)lobal,\n    (l)ocal, (h)ere\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls delete_alias -a build -d l\n    Removes the entry for alias 'build' from the closest local file.\n"
    printf "  pls d -a deploy -d g\n    Removes the entry for alias 'deploy' from the global file.\n"
    printf "  pls d -a foo -d h\n    Removes the entry for alias 'foo' from the file in the current directory.\n"
    echo

  fi
}

# :command.usage
pls_list_aliases_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls list_aliases\n\n"
    printf "  List all aliases available for invocation in the current directory.\n\n"
  else
    printf "pls list_aliases - List all aliases available for invocation in the current directory.\n\n"
  fi
  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pls list_aliases [OPTIONS]\n"
  printf "  pls list_aliases --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Lists only aliases available in the local context.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--global, -g"
    printf "    Lists only aliases available in the global context.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Shows aliases in local and global context, even if local alias overwrites\n    global.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--command, -c"
    printf "    Also show the command associated with each alias.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls list_aliases\n    Lists all aliases avaliable in the current directory.\n"
    printf "  pls l -gc\n    Lists all aliases that are stored in the file at \$PLS_GLOBAL, and\n  additionally shows the command associated with each alias.\n"
    echo

  fi
}

# :command.usage
pls_pick_alias_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls pick_alias\n\n"
    printf "  Pick an alias from the list of available aliases to execute.\n  Note: This supports fuzzy finder 'fzf' if you have it installed.\n\n"
  else
    printf "pls pick_alias - Pick an alias from the list of available aliases to execute.\n\n"
  fi
  printf "Alias: p\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pls pick_alias\n"
  printf "  pls pick_alias --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls pick_alias\n    Starts an interactive prompt to select an alias to execute.\n  pls p\n    Same as above.\n  pls\n    Same as above.\n"
    echo

  fi
}

# :command.usage
pls_clear_cache_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls clear_cache\n\n"
    printf "  Clear the cache of all commands that have been run with pls.\n\n"
  else
    printf "pls clear_cache - Clear the cache of all commands that have been run with pls.\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  pls clear_cache\n"
  printf "  pls clear_cache --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pls clear_cache\n"
    echo

  fi
}

# :command.usage
pls_this_does_nothing_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls this_does_nothing\n\n"
    printf "  This command is just for testing purposes.\n  It does nothing. It is only used to test the before hook.\n\n"
  else
    printf "pls this_does_nothing - This command is just for testing purposes.\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  pls this_does_nothing\n"
  printf "  pls this_does_nothing --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/cache/add_to_cache.sh
add_to_cache() {
  local origin="$1" # Is a file path, so can contain special characters such as whitespace
  local alias="$2" # Is a string which cannot be multiline
  local command="$3" # Is a string which can be multiline
  local cache_file="$PLS_DIR/.cache.yml"

  # Check if all arguments are provided
  if [ -z "$origin" ] || [ -z "$alias" ] || [ -z "$command" ]; then
    echo "Usage Error: add_to_cache <origin> <alias> <command>" >&2
    return 1
  fi

  # Create cache if it does not exist
  if [[ ! -d "$PLS_DIR" ]]; then
    echo "Env Error: PLS_DIR is not set or is not a directory" >&2
    return 1
  fi
  [[ ! -f "$cache_file" ]] && touch "$cache_file"

  local escaped_command=$(printf '%s' "$command" | sed 's/"/\\"/g')

  yq -i eval ".[\"$origin\"][\"$alias\"] = \"$escaped_command\"" "$cache_file"
}

# src/lib/cache/exists_in_cache.sh
exists_in_cache() {
  local origin="$1"
  local alias="$2"
  local command="$3"

  if [[ -z "$origin" || -z "$alias" || -z "$command" ]]; then
    echo "Usage Error: exists_in_cache <origin> <alias> <command>" >&2
    return 1
  fi

  if [ ! -f "$PLS_DIR/.cache.yml" ]; then
    return 1
  fi

  local result=$(yq eval ".[\"$origin\"][\"$alias\"]" "$PLS_DIR/.cache.yml")
  if [[ "$result" == "null" ]]; then
    return 1
  fi

  if [[ ! "$(printf "$command")" == "$result" ]]; then
    return 1
  fi
}

# src/lib/helpers/destination_to_path.sh
destination_to_path() {
  local destination="$1"
  # If the destination is "g" or "global", return the global destination
  if [ "$destination" == "g" ] || [ "$destination" == "global" ]; then
    echo "$PLS_GLOBAL"
    return 0
  # If the destination is "l" or "local", return the closest file
  elif [ "$destination" == "l" ] || [ "$destination" == "local" ]; then
    local closest_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"
    echo "$closest_file"
    return 0
  # Return destination in the current directory
  elif [ "$destination" == "h" ] || [ "$destination" == "here" ]; then
    echo "$(realpath $PWD/$PLS_FILENAME)"
    return 0
  fi
  echo "Error: Invalid argument. Must be one of [ g, global, l, local, h, here ]" >&2
  return 1
}

# src/lib/helpers/get_closest_file.sh
get_closest_file() {
    local from_dir="$1"
    local target_file="$2"
    local mock_root="$3"

    # Traverse up the directory tree until we find the target file
    # or reach the root directory.
    # If we reach the root directory, return an empty string.
    local current_dir="$(realpath $from_dir)"
    while [ "$current_dir" != "/" ]; do
        local file_path="$current_dir/$target_file"
        if [[ -f "$file_path" && "$file_path" != "$PLS_GLOBAL" ]]; then
            # Echo the path of the file
            # (If the current directory is the mock root,
            #  return path as if it were the root directory)
            echo "$([[ "$current_dir" == "$mock_root" ]] && \
              echo "/$target_file" || echo "$current_dir/$target_file"
            )"
            return 0
        fi
        current_dir=$(dirname $(realpath "$current_dir"))
    done
    if [[ -f "/$target_file" ]]; then
        echo "/$target_file" && return 0
    fi
}

# src/lib/helpers/merge_pls_files.sh
merge_pls_files() {
    local global_file="$1"
    local local_file="$2"
    local combined_file="$(mktemp)"

    # Start with an empty, valid pls file
    echo "commands:" > "$combined_file"
    # If both files exist, merge them
    if [ -f "$local_file" ] && [ -f "$global_file" ]; then
      # Combine into a single yml with nodes 'local' and global' respectively
      local temp_file="$(mktemp)"
      sed "s/commands:/local:/" "$local_file" > "$temp_file"
      sed "s/commands:/global:/" "$global_file" >> "$temp_file"
      # Add a (*) to all aliases that are in the global: section
      yq e -i '.commands = ((.global | map(.alias = .alias + " *")) + .local) | del(.global,.local)' "$temp_file"
      # Combine the two sections into a single section
      # Conflicts are resolved by taking the alias that does not have a * at the end
      yq eval '
        .commands |= (
        map(select(.alias | test(" \\*$") | not)) +

        map(select(.alias | test(" \\*$"))) |

        unique_by(.alias | sub(" \\*$"; "")) |
        sort_by(.alias)
      )' "$temp_file" > "$combined_file"
    elif [ -f "$local_file" ]; then
      # If the file has no entries, we are already done
      if [[ "$(yq e '.commands | length' "$local_file")" -eq 0 ]]; then
        return
      fi
      yq eval '.commands | sort_by(.alias)' "$local_file" >> "$combined_file"
    elif [ -f "$global_file" ]; then
      # If the file has no entries, we are already done
      if [[ "$(yq e '.commands | length' "$global_file")" -eq 0 ]]; then
        return
      fi
      # Else use the global file and add a (*) to all aliases
      yq eval '.commands | map(.alias = .alias + " *") | sort_by(.alias)' "$global_file" >> "$combined_file"
    fi
    cat "$combined_file"
    rm "$combined_file"
}

# src/lib/query/add_entry_to_file.sh
add_entry_to_file() {
  local alias="$1"
  local command="$2"
  local target_file="$3"

  if [[ -z "$alias" || -z "$command" || -z "$target_file" ]]; then
    echo "Usage Error: add_entry_to_file <alias> <command> <file>" >&2
    return 1
  fi

  if [ ! -f "$target_file" ]; then
    echo "Error: Can not add to file '$target_file' as it does not exist." >&2
    return 1
  fi

  yq e -i ".commands += [{\"alias\": \"$alias\", \"command\": \"$command\"}]" "$target_file"
}

# src/lib/query/delete_entry_from_file.sh
delete_entry_from_file() {
  local alias="$1"
  local file="$2"

  if [[ -z "$alias" || -z "$file" ]]; then
    echo "Usage Error: delete_entry_from_file <alias> <file>" >&2

    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "Error: Can not delete from file '$file' as it does not exist." >&2
    return 1
  fi

  yq e -i "del(.commands[] | select(.alias == \"$alias\"))" "$file"
}

# src/lib/query/query_command.sh
query_command() {
  local alias="$1"
  local report_found_in="$2" || 0

  if [ -z "$alias" ]; then
    echo "Usage Error: Alias cannot be empty." >&2
    return 1
  fi

  local global_file="$PLS_GLOBAL"
  local local_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"

  local command
  local found_in
  if [ -f "$global_file" ]; then
    local result=$(query_command_in_file "$alias" "$global_file")
    if [ -n "$result" ]; then
      command="$result"
      found_in="$global_file"
    fi
  fi

  if [ -f "$local_file" ]; then
    local result=$(query_command_in_file "$alias" "$local_file")
    if [ -n "$result" ]; then
      command="$result"
      found_in="$local_file"
    fi
  fi

  echo "$command"
  if [ $report_found_in ]; then
    echo "$found_in"
  fi
}

# src/lib/query/query_command_in_file.sh
query_command_in_file() {
  local alias="$1"
  local file="$2"

  if [ -z "$alias" ]; then
    echo "Usage Error: Alias cannot be empty." >&2
    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "Usage Error: '$file' does not exist." >&2
    return 1
  fi

  local command="$(yq ".commands | map(select(.alias == \"$alias\"))[0] | .command" "$file")"
  [[ $command == "null" ]] && echo "" || echo "$command"

}

# src/lib/validations/validate_format_of_files.sh
validate_format_of_file() {
  local file="$1"
  # # Check if 'commands' is the only top-level node
  local toplevel_nodes_count="$(yq 'length' "$file")"
  local commands_nodes_count
  if [[ "$(yq '. == null' "$file")" == "true" ]]; then
    commands_nodes_count=0
  else
    commands_nodes_count="$(yq 'keys | map(select(. == "commands")) | length' "$file")"
  fi
  if [[ "$toplevel_nodes_count" -gt 1 || "$commands_nodes_count" -ne 1 ]]; then
    echo "Format Error: '$file' should have 'commands' as the (only) top-level node." >&2
    echo "It currently has $toplevel_nodes_count top-level nodes." >&2
    echo "$commands_nodes_count of which are titled 'commands'." >&2
    return 1
  fi

  # Check if 'commands' has an equal number of 'alias' and 'command' keys
  local size_of_commands_array="$(yq '.commands | length' "$file")"
  local num_of_aliases="$(yq '.commands | map(select(has("alias"))) | length' "$file")"
  local num_of_command="$(yq '.commands | map(select(has("command"))) | length' "$file")"
  if [[ "$size_of_commands_array" -ne "$num_of_aliases" || "$size_of_commands_array" -ne "$num_of_command" ]]; then
    echo "Format Error: '$file' should have 'alias' and 'command' for each command." >&2
    echo "It currently has $size_of_commands_array commands." >&2
    echo "  $num_of_aliases of which have a key 'alias'." >&2
    echo "  $num_of_command of which have a key 'command'." >&2
    return 1
  fi

  if [[ "$size_of_commands_array" -eq 0 ]]; then
    return 0
  fi

  # Check if all 'alias' have no newlines
  local num_of_aliases_with_newlines="$(yq '.commands | map(select(.alias | contains("\n"))) | length' "$file")"
  if [[ "$num_of_aliases_with_newlines" -gt 0 ]]; then
    echo "Format Error: '$file' should not have newlines in aliases." >&2
    echo "It currently has $num_of_aliases_with_newlines aliases with newlines." >&2
    return 1
  fi

  # Check if all 'alias' are unique
  local aliases="$(yq '.commands[].alias' "$file")"
  local unique_aliases="$(echo "$aliases" | sort | uniq)"
  local num_of_unique_aliases="$(echo "$unique_aliases" | wc -l)"
  if [[ "$num_of_aliases" -ne "$num_of_unique_aliases" ]]; then
    echo "Format Error: '$file' should have unique aliases." >&2
    echo "It currently has $num_of_aliases aliases, but there are only $num_of_unique_aliases unique names." >&2
    echo "The following aliases are duplicated:" >&2
    diff --changed-group-format='%<' --unchanged-group-format='' <(echo "$aliases" | sort) <(echo "$unique_aliases" | sort) >&2

    return 1
  fi

  # Check if all 'command' are not empty
  local num_of_empty_commands="$(yq '.commands | map(select(.command | test("^\\s*$"))) | length' "$file")"
  if [[ "$num_of_empty_commands" -gt 0 ]]; then
    echo "Format Error: '$file' should not have empty 'command' keys." >&2
    echo "It currently has $num_of_empty_commands empty 'command' keys." >&2
    return 1
  fi
}

validate_format_of_files() {
  local global_file="$PLS_GLOBAL"
  local local_file=$(get_closest_file "$PWD" "$PLS_FILENAME")

  if [[ -f "$global_file" ]]; then
    validate_format_of_file "$global_file"
  fi

  if [[ -f "$local_file" ]]; then
    validate_format_of_file "$local_file"
  fi
}

# src/lib/validations/validate_is_destination.sh
validate_is_destination() {
  local arg="$1"
  [ "$arg" != "g" ] && [ "$arg" != "l" ] && [ "$arg" != "h" ] && [ "$arg" != "global" ] && [ "$arg" != "local" ] && [ "$arg" != "here" ] && echo "Error: Invalid argument. Must be one of [ g, global, l, local, h, here ]"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/workers/execute_alias.sh
execute_alias() {
  local alias="$1"

  local result=$(query_command "$alias" 1)

  # command is all but last line
  local command=$(echo "$result" | head -n -1)
  # found_in is the last line
  local found_in=$(echo "$result" | tail -n 1)

  # If no command found, exit
  if [ -z "$command" ]; then
    echo "Alias '$alias' was not found."
    exit 1
  fi

  prompt_to_continue() {
      if [[ "$is_cached" == "true" ]]; then
        echo "This command is already cached."
      fi
      echo

      echo "$command"
      echo
      read -p "Are you sure you want to invoke the above command? [y/n] " -n 1 -r
      echo

      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Command was not invoked."
        echo "Exiting..."
        exit 1
      fi
  }

  if exists_in_cache "$found_in" "$alias" "$command"; then
      if [[ "$PLS_ALWAYS_VERIFY" == "true" ]]; then
        prompt_to_continue
      fi

  elif [[ "$PLS_ENABLE_CACHE_CHECK" == "true" || "$PLS_ALWAYS_VERIFY" == "true" ]]; then
      echo "Alias '$alias' was found in '$found_in', but this command seems new."
      prompt_to_continue
  fi

  command_args="${args[command_args]}"
  # Create a temporary function
  exec_alias_command() {
      eval "$command"
  }

  # Execute the function with the arguments
  exec_alias_command $command_args

  add_to_cache "$found_in" "$alias" "$command"
}

# src/lib/workers/list_aliases.sh
list_aliases() {
  local flag_command="${args[--command]}"
  local flag_global="${args[--global]}"
  local flag_local="${args[--local]}"
  local flag_all="${args[--all]}"

  local local_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"
  local global_file="$PLS_GLOBAL"

  print_aliases() {
    local file="$1"
    local should_print_command="$2"

    if [[ ! -f "$file" || "$(yq e '.commands | length' "$file")" -eq 0 ]]; then
      echo "No aliases found."
      return
    fi
    local alias_query='.commands | sort_by(.alias) | .[] | .alias'
    local command_query='.commands | sort_by(.alias) | .[] | .alias + "\n" + (.command | split("\n") | map(select(. != "") | "   " + .) | join("\n"))'
    yq e "$([[ "$should_print_command" ]] && echo "$command_query" || echo "$alias_query")" "$file"
  }

  if [[ "$flag_all" ]]; then
    echo "--- Global Aliases ---"
    print_aliases "$global_file" "$flag_command"
    echo "--- Local Aliases ---"
    print_aliases "$local_file" "$flag_command"
  elif [[ "$flag_global" ]]; then
    print_aliases "$global_file" "$flag_command"
  elif [[ "$flag_local" ]]; then
    print_aliases "$local_file" "$flag_command"
  else
    local temp_combined_file="$(mktemp)"
    echo "$(merge_pls_files "$global_file" "$local_file")" > "$temp_combined_file"
    print_aliases "$temp_combined_file" "$flag_command"
    rm "$temp_combined_file"
  fi
}

# src/lib/workers/pick_and_execute_alias.sh
pick_and_execute_alias() {
  current_list="$(list_aliases)"

  if [[ "$current_list" == "No aliases found." ]]; then
    echo "No aliases found."
    exit 0
  fi

  # if fzf is not installed, exit
  if [[ "$PLS_ENABLE_FZF" == "true" && $(command -v fzf &> /dev/null) -eq 0 ]]; then
    picked_alias="$(echo "$current_list" | fzf --height 40% --reverse --prompt="Enter alias: ")"
    # Remove ' *' from the end of the alias if it exists
  else
    # print the list with
    # 1 | content
    echo "$current_list" | awk '{print NR " | " $0}'
    read -p "Enter alias (or n): " input
    if [[ "$input" =~ ^[0-9]+$ && "$input" -gt 0 ]]; then
      # Get alias from line number
      picked_alias="$(echo "$current_list" | sed -n "${input}p")"
    else
      # actually entered an alias instead of a number

      picked_alias="$input"
    fi
  fi
  picked_alias="${picked_alias% \*}"
  execute_alias "$picked_alias"
}

# :command.command_functions
# :command.function
pls_execute_alias_command() {
  # src/execute_alias_command.sh
  if [ -z "${args[alias]}" ]; then
    pick_and_execute_alias
  else

    execute_alias "${args[alias]}"
  fi

}

# :command.function
pls_add_alias_command() {
  # src/add_alias_command.sh
  alias="${args[--alias]}"
  command="${args[--command]}"
  destination="${args[--destination]}"

  target_file="$(destination_to_path "$destination")"

  if [[ -z "$target_file" && ("$destination" == "local" || "$destination" == "l") ]]; then
    target_file="$(realpath .)/$PLS_FILENAME"

  fi

  # Create file if it does not exist
  if [ ! -f "$target_file" ]; then
    echo "commands:" > "$target_file"
  fi

  # If alias already exists in file, --force flag must be used
  num_occurances_of_alias="$(yq e ".commands | map(select(.alias == \"$alias\")) | length" "$target_file")"
  if [[ $num_occurances_of_alias -eq 1 ]]; then
    if [ ! "${args[--force]}" ]; then
      echo "Error: Alias '$alias' already exists in file '$target_file'. Use --force to overwrite." >&2
      exit 1
    fi
    # Remove the old alias
    delete_entry_from_file "$alias" "$target_file"
  fi

  # Add alias:command entry to file
  add_entry_to_file "$alias" "$command" "$target_file"

}

# :command.function
pls_delete_alias_command() {
  # src/delete_alias_command.sh

  alias="${args[--alias]}"
  destination="${args[--destination]}"

  target_file="$(destination_to_path "$destination")"

  if [[ -z "$target_file" ]]; then
    echo "Error: Can not delete from local file as it does exist here or in any parent." >&2
    exit 1
  fi

  delete_entry_from_file "$alias" "$target_file"

}

# :command.function
pls_list_aliases_command() {
  # src/list_aliases_command.sh
  list_aliases

}

# :command.function
pls_pick_alias_command() {
  # src/pick_alias_command.sh
  pick_and_execute_alias

}

# :command.function
pls_clear_cache_command() {
  # src/clear_cache_command.sh
  rm "$PLS_DIR/.cache.yml"

}

# :command.function
pls_this_does_nothing_command() {
  # src/this_does_nothing_command.sh
  # This command does nothing!
  # It is used for internal testing purposes only.
  # It allows us to run the before / after hooks without actually doing anything.
  # The 'eval' is just in place to make sure this file is not empty,
  # as that would cause an error in the bashly build.
  eval

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        pls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PLS_FILENAME="${PLS_FILENAME:-.pls.yml}"
  export PLS_GLOBAL="${PLS_GLOBAL:-$(echo $HOME/$PLS_FILENAME)}"
  export PLS_DIR="${PLS_DIR:-$(echo $HOME/.local/share/pls)}"
  export PLS_ENABLE_CACHE_CHECK="${PLS_ENABLE_CACHE_CHECK:-true}"
  export PLS_ALWAYS_VERIFY="${PLS_ALWAYS_VERIFY:-false}"
  export PLS_ENABLE_FZF="${PLS_ENABLE_FZF:-true}"

  env_var_names+=("PLS_FILENAME")
  env_var_names+=("PLS_GLOBAL")
  env_var_names+=("PLS_DIR")
  env_var_names+=("PLS_ENABLE_CACHE_CHECK")
  env_var_names+=("PLS_ALWAYS_VERIFY")
  env_var_names+=("PLS_ENABLE_FZF")

  # :command.dependencies_filter
  if command -v yq >/dev/null 2>&1; then
    deps['yaml_parser']="$(command -v yq | head -n1)"
  else
    printf "missing dependency: yaml_parser\n" >&2
    printf "%s\n" "See https://github.com/mikefarah/yq for installation instructions." >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    execute_alias | e)
      action="execute_alias"
      shift
      pls_execute_alias_parse_requirements "$@"
      shift $#
      ;;

    add_alias | a)
      action="add_alias"
      shift
      pls_add_alias_parse_requirements "$@"
      shift $#
      ;;

    delete_alias | r)
      action="delete_alias"
      shift
      pls_delete_alias_parse_requirements "$@"
      shift $#
      ;;

    list_aliases | l)
      action="list_aliases"
      shift
      pls_list_aliases_parse_requirements "$@"
      shift $#
      ;;

    pick_alias | p)
      action="pick_alias"
      shift
      pls_pick_alias_parse_requirements "$@"
      shift $#
      ;;

    clear_cache)
      action="clear_cache"
      shift
      pls_clear_cache_parse_requirements "$@"
      shift $#
      ;;

    this_does_nothing)
      action="this_does_nothing"
      shift
      pls_this_does_nothing_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    *)
      action="execute_alias"
      pls_execute_alias_parse_requirements "$@"
      shift $#
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pls_execute_alias_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_execute_alias_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="execute_alias"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable
        # :argument.case_repeatable
        escaped="$(printf '%q' "$1")"
        if [[ -z ${args['alias']+x} ]]; then
          args['alias']="$1"

        # :argument.case_repeatable
        elif [[ -z ${args['command_args']+x} ]]; then
          args['command_args']="$escaped"
        else
          args['command_args']="${args['command_args']} $escaped"

        fi
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
pls_add_alias_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_add_alias_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add_alias"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --alias | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--alias']="$2"
          shift
          shift
        else
          printf "%s\n" "--alias requires an argument: --alias, -a ALIAS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --command | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--command']="$2"
          shift
          shift
        else
          printf "%s\n" "--command requires an argument: --command, -c COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --destination | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--destination']="$2"
          shift
          shift
        else
          printf "%s\n" "--destination requires an argument: --destination, -d DESTINATION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--alias']+x} ]]; then
    printf "missing required flag: --alias, -a ALIAS\n" >&2
    exit 1
  fi
  if [[ -z ${args['--command']+x} ]]; then
    printf "missing required flag: --command, -c COMMAND\n" >&2
    exit 1
  fi
  if [[ -z ${args['--destination']+x} ]]; then
    printf "missing required flag: --destination, -d DESTINATION\n" >&2
    exit 1
  fi

  # :command.validations
  # :flag.validations
  if [[ -v args['--alias'] && -n $(validate_not_empty "${args['--alias']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--alias, -a ALIAS" "$(validate_not_empty "${args['--alias']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--command'] && -n $(validate_not_empty "${args['--command']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--command, -c COMMAND" "$(validate_not_empty "${args['--command']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--destination'] && -n $(validate_is_destination "${args['--destination']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--destination, -d DESTINATION" "$(validate_is_destination "${args['--destination']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pls_delete_alias_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_delete_alias_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="delete_alias"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --alias | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--alias']="$2"
          shift
          shift
        else
          printf "%s\n" "--alias requires an argument: --alias, -a ALIAS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --destination | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--destination']="$2"
          shift
          shift
        else
          printf "%s\n" "--destination requires an argument: --destination, -d DESTINATION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--alias']+x} ]]; then
    printf "missing required flag: --alias, -a ALIAS\n" >&2
    exit 1
  fi
  if [[ -z ${args['--destination']+x} ]]; then
    printf "missing required flag: --destination, -d DESTINATION\n" >&2
    exit 1
  fi

  # :command.validations
  # :flag.validations
  if [[ -v args['--alias'] && -n $(validate_not_empty "${args['--alias']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--alias, -a ALIAS" "$(validate_not_empty "${args['--alias']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--destination'] && -n $(validate_is_destination "${args['--destination']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--destination, -d DESTINATION" "$(validate_is_destination "${args['--destination']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pls_list_aliases_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_list_aliases_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list_aliases"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --local | -l)
        # :flag.conflicts
        for conflict in --global --all; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --global | -g)
        # :flag.conflicts
        for conflict in --local --all; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--global']=1
        shift
        ;;

      # :flag.case
      --all | -a)
        # :flag.conflicts
        for conflict in --local --global; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      # :flag.case
      --command | -c)

        # :flag.case_no_arg
        args['--command']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pls_pick_alias_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_pick_alias_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pick_alias"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pls_clear_cache_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_clear_cache_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clear_cache"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pls_this_does_nothing_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pls_this_does_nothing_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="this_does_nothing"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  mkdir -p $PLS_DIR
  if [ ! -d $PLS_DIR ]; then
      echo "Failed to create directory $PLS_DIR"

      exit 1
  fi

  validate_format_of_files

}

# :command.initialize
initialize() {
  version=""
  long_usage=''
  set -e

  # :command.environment_variables_default
  export PLS_FILENAME="${PLS_FILENAME:-.pls.yml}"
  export PLS_GLOBAL="${PLS_GLOBAL:-$(echo $HOME/$PLS_FILENAME)}"
  export PLS_DIR="${PLS_DIR:-$(echo $HOME/.local/share/pls)}"
  export PLS_ENABLE_CACHE_CHECK="${PLS_ENABLE_CACHE_CHECK:-true}"
  export PLS_ALWAYS_VERIFY="${PLS_ALWAYS_VERIFY:-false}"
  export PLS_ENABLE_FZF="${PLS_ENABLE_FZF:-true}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "execute_alias") pls_execute_alias_command ;;
    "add_alias") pls_add_alias_command ;;
    "delete_alias") pls_delete_alias_command ;;
    "list_aliases") pls_list_aliases_command ;;
    "pick_alias") pls_pick_alias_command ;;
    "clear_cache") pls_clear_cache_command ;;
    "this_does_nothing") pls_this_does_nothing_command ;;
  esac
}

initialize
run "$@"
