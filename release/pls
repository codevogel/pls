#!/usr/bin/env bash
# This script was generated by bashly 1.2.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  alias="${args[alias]}"
  flag_add="${args[--add]}"
  flag_command="${args[--command]}"
  flag_target="${args[--target]}"
  flag_delete="${args[--delete]}"
  flag_list="${args[--list]}"
  flag_clear_cache="${args[--clear-cache]}"
  flag_this_does_nothing="${args[--this-does-nothing]}"

  if [ -n "$flag_this_does_nothing" ]; then
    exit
  fi

  if [ -n "$flag_clear_cache" ]; then
    rm -f "$PLS_DIR/.cache.yml"
    if [ ${#args[@]} -eq 1 ]; then
      exit
    fi
  fi

  if [ -n "$flag_delete" ]; then
    delete_alias
    exit
  fi

  if [ -n "$flag_add" ]; then
    add_alias
    exit
  fi

  if [ -n "$flag_list" ]; then
    list_aliases 0
    exit
  fi

  if [ -z "$alias" ]; then
    pick_and_execute_alias
  else

    execute_alias "$alias"
  fi

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
pls_usage() {
  if [[ -n $long_usage ]]; then
    printf "pls\n\n"
    printf "  Project Level Shortcuts (pls) is a command-line tool designed to streamline \n  your workflow by allowing you to create, manage, and execute custom aliases \n  for frequently used commands.\n  \n  Key features:\n   * Easy alias creation and modification\n        Add, remove, rename, or change functionality of aliases with a simple\n        CLI interface.\n   * Project Level Specificity \n        Aliases can be defined at both project and global levels, with\n        project-specific aliases taking precedence.\n   * Intuitive command execution:\n        Run a command associated with an alias using the 'pls' prefix.\n        e.g. pls open, pls test, pls deploy\n   * Easily shareable aliases:\n        Streamline your team's workflow by sharing aliases across projects, or\n        make setup of your product dead-easy for your users.\n        Just add a pls file to the project's root directory, and you're off!\n  \n  To see examples of how to use pls, run 'pls <command> --help'\n\n"
  else
    printf "pls - Project Level Shortcuts (pls) is a command-line tool designed to streamline \n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  pls [ALIAS] [COMMAND_ARGS...] [OPTIONS]\n"
  printf "  pls --help | -h\n"
  printf "  pls --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--add, -a"
    printf "    OPERATION: Adds a new alias for a --command to the pls file at a given\n    --scope.\n"
    printf "    Needs: --command, --scope\n"
    echo

    # :flag.usage
    printf "  %s\n" "--delete, -d"
    printf "    OPERATION: Delete the alias from the pls file at given --scope.\n"
    printf "    Needs: --scope\n"
    echo

    # :flag.usage
    printf "  %s\n" "--list, -l"
    printf "    OPERATION: List all aliases available in the current directory.\n    Or, list aliases only from --scope <[g]lobal, [l]ocal, [a]ll>.\n    Use with --print to print the command associated with each alias.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--command, -c COMMAND"
    printf "    ARGFLAG: Supplies a command to associate with the alias in the  --add\n    operation.\n    Pass the command as a string, newline characters ('\\\n') are allowed.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    ARGFLAG: The selected scope for --add, --delete, and --list operations.\n    The 'all' scope is exclusive to --list.\n    The 'here' scope is excluded from --list.\n"
    printf "    Allowed: g, global, l, local, h, here, a, all\n"
    echo

    # :flag.usage
    printf "  %s\n" "--print, -p"
    printf "    Prints the command instead of executing it. Useful for piping to other\n    commands or shells.\n    Or, if used in conjunction with --list, it additionally prints the command\n    for each alias.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite the alias if it already exists when using the --add operation.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--clear-cache"
    printf "    Before doing anything, clears the cache of all commands that have been run\n    with pls.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ALIAS"
    printf "    The alias to execute, add, or delete.\n    When left empty, will launch an interactive picker to select and execute an\n    alias.\n"
    echo

    # :argument.usage
    printf "  %s\n" "COMMAND_ARGS..."
    printf "    Optional arguments to pass to the command when executing a parameterized\n    command.\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PLS_RC"
    printf "    The path to the configuration file to use. Contains additional environment\n    variables for advanced users. Default is determined by\n    '\$HOME/.config/pls/.plsrc'.\n"
    printf "    Default: $HOME/.config/pls/.plsrc\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/cache/add_to_cache.sh
add_to_cache() {
  local origin="$1" # Is a file path, so can contain special characters such as whitespace
  local alias="$2" # Is a string which cannot be multiline
  local command="$3" # Is a string which can be multiline
  local cache_file="$PLS_DIR/.cache.yml"

  # Check if all arguments are provided
  if [ -z "$origin" ] || [ -z "$alias" ] || [ -z "$command" ]; then
    echo "Usage Error: add_to_cache <origin> <alias> <command>" >&2
    return 1
  fi

  # Create cache if it does not exist
  if [[ ! -d "$PLS_DIR" ]]; then
    echo "Env Error: PLS_DIR is not set or is not a directory" >&2
    return 1
  fi
  [[ ! -f "$cache_file" ]] && touch "$cache_file"

  local escaped_command=$(printf '%s' "$command" | sed 's/"/\\"/g')

  yq -i eval ".[\"$origin\"][\"$alias\"] = \"$escaped_command\"" "$cache_file"
}

# src/lib/cache/exists_in_cache.sh
exists_in_cache() {
  local origin="$1"
  local alias="$2"
  local command="$3"

  if [[ -z "$origin" || -z "$alias" || -z "$command" ]]; then
    echo "Usage Error: exists_in_cache <origin> <alias> <command>" >&2
    return 1
  fi

  if [ ! -d "$PLS_DIR" ]; then
    echo "Directory not found at $PLS_DIR" >&2
    return 1
  fi

  if [ ! -f "$PLS_DIR/.cache.yml" ]; then
    return 1
  fi

  local result=$(yq eval ".[\"$origin\"][\"$alias\"]" "$PLS_DIR/.cache.yml")
  if [[ "$result" == "null" ]]; then
    return 1
  fi

  if [[ ! "$(printf "$command")" == "$result" ]]; then
    return 1
  fi
}

# src/lib/helpers/check_version.sh
check_version() {
  local min_version="$1"
  local actual_version="$2"
  if [[ "$(printf '%s\n%s' "$min_version" "$actual_version" | sort -V | head -n1)" != "$min_version" ]]; then
    return 1
  fi
}

# src/lib/helpers/get_closest_file.sh
get_closest_file() {
    local from_dir="$1"
    local target_file="$2"
    local mock_root="$3"

    # Traverse up the directory tree until we find the target file
    # or reach the root directory.
    # If we reach the root directory, return an empty string.
    local current_dir="$(realpath $from_dir)"
    while [ "$current_dir" != "/" ]; do
        local file_path="$current_dir/$target_file"
        if [[ -f "$file_path" && "$file_path" != "$PLS_GLOBAL" ]]; then
            # Echo the path of the file
            # (If the current directory is the mock root,
            #  return path as if it were the root directory)
            echo "$([[ "$current_dir" == "$mock_root" ]] && \
              echo "/$target_file" || echo "$current_dir/$target_file"
            )"
            return 0
        fi
        current_dir=$(dirname $(realpath "$current_dir"))
    done
    if [[ -f "/$target_file" ]]; then
        echo "/$target_file" && return 0
    fi
}

# src/lib/helpers/merge_pls_files.sh
merge_pls_files() {
    local global_file="$1"
    local local_file="$2"
    local combined_file="$(mktemp)"

    # Start with an empty, valid pls file
    echo "commands:" > "$combined_file"
    # If both files exist, merge them
    if [ -f "$local_file" ] && [ -f "$global_file" ]; then
      # Combine into a single yml with nodes 'local' and global' respectively
      local temp_file="$(mktemp)"
      sed "s/commands:/local:/" "$local_file" > "$temp_file"
      sed "s/commands:/global:/" "$global_file" >> "$temp_file"
      # Add a (*) to all aliases that are in the global: section
      yq e -i '.commands = ((.global | map(.alias = .alias + " *")) + .local) | del(.global,.local)' "$temp_file"
      # Combine the two sections into a single section
      # Conflicts are resolved by taking the alias that does not have a * at the end
      yq eval '
        .commands |= (
        map(select(.alias | test(" \\*$") | not)) +

        map(select(.alias | test(" \\*$"))) |

        unique_by(.alias | sub(" \\*$"; "")) |
        sort_by(.alias)
      )' "$temp_file" > "$combined_file"
    elif [ -f "$local_file" ]; then
      # If the file has no entries, we are already done
      if [[ "$(yq e '.commands | length' "$local_file")" -eq 0 ]]; then
        return
      fi
      yq eval '.commands | sort_by(.alias)' "$local_file" >> "$combined_file"
    elif [ -f "$global_file" ]; then
      # If the file has no entries, we are already done
      if [[ "$(yq e '.commands | length' "$global_file")" -eq 0 ]]; then
        return
      fi
      # Else use the global file and add a (*) to all aliases
      yq eval '.commands | map(.alias = .alias + " *") | sort_by(.alias)' "$global_file" >> "$combined_file"
    fi
    cat "$combined_file"
    rm "$combined_file"
}

# src/lib/helpers/scope_to_path.sh
scope_to_path() {
  local scope="$1"
  # If the target is "g" or "global", return the global destination
  if [ "$scope" == "g" ] || [ "$scope" == "global" ]; then
    echo "$PLS_GLOBAL"
    return 0
  # If the target is "l" or "local", return the closest file
  elif [ "$scope" == "l" ] || [ "$scope" == "local" ]; then
    local closest_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"
    echo "$closest_file"
    return 0
  # Return target in the current directory
  elif [ "$scope" == "h" ] || [ "$scope" == "here" ]; then
    echo "$(realpath $PWD/$PLS_FILENAME)"
    return 0
  fi
  echo "Error: Invalid argument. Must be one of [ g, global, l, local, h, here ]" >&2
  return 1
}

# src/lib/query/add_entry_to_file.sh
add_entry_to_file() {
  local alias="$1"
  local command="$2"
  local target_file="$3"

  if [[ -z "$alias" || -z "$command" || -z "$target_file" ]]; then
    echo "Usage Error: add_entry_to_file <alias> <command> <file>" >&2
    return 1
  fi

  if [ ! -f "$target_file" ]; then
    echo "Error: Can not add to file '$target_file' as it does not exist." >&2
    return 1
  fi

  yq e -i ".commands += [{\"alias\": \"$alias\", \"command\": \"$command\"}]" "$target_file"
}

# src/lib/query/delete_entry_from_file.sh
delete_entry_from_file() {
  local alias="$1"
  local file="$2"

  if [[ -z "$alias" || -z "$file" ]]; then
    echo "Usage Error: delete_entry_from_file <alias> <file>" >&2

    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "Error: Can not delete from file '$file' as it does not exist." >&2
    return 1
  fi

  yq e -i "del(.commands[] | select(.alias == \"$alias\"))" "$file"
}

# src/lib/query/query_command.sh
query_command() {
  local alias="$1"
  local report_found_in="$2" || 0

  if [ -z "$alias" ]; then
    echo "Usage Error: Alias cannot be empty." >&2
    return 1
  fi

  local global_file="$PLS_GLOBAL"
  local local_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"

  local command
  local found_in
  if [ -f "$global_file" ]; then
    local result=$(query_command_in_file "$alias" "$global_file")
    if [ -n "$result" ]; then
      command="$result"
      found_in="$global_file"
    fi
  fi

  if [ -f "$local_file" ]; then
    local result=$(query_command_in_file "$alias" "$local_file")
    if [ -n "$result" ]; then
      command="$result"
      found_in="$local_file"
    fi
  fi

  echo "$command"
  if [ $report_found_in ]; then
    echo "$found_in"
  fi
}

# src/lib/query/query_command_in_file.sh
query_command_in_file() {
  local alias="$1"
  local file="$2"

  if [ -z "$alias" ]; then
    echo "Usage Error: Alias cannot be empty." >&2
    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "Usage Error: '$file' does not exist." >&2
    return 1
  fi

  local command="$(yq ".commands | map(select(.alias == \"$alias\"))[0] | .command" "$file")"
  [[ $command == "null" ]] && echo "" || echo "$command"

}

# src/lib/validations/validate_format_of_files.sh
validate_format_of_file() {
  local file="$1"
  # # Check if 'commands' is the only top-level node
  local toplevel_nodes_count="$(yq 'length' "$file")"
  local commands_nodes_count
  if [[ "$(yq '. == null' "$file")" == "true" ]]; then
    commands_nodes_count=0
  else
    commands_nodes_count="$(yq 'keys | map(select(. == "commands")) | length' "$file")"
  fi
  if [[ "$toplevel_nodes_count" -gt 1 || "$commands_nodes_count" -ne 1 ]]; then
    echo "Format Error: '$file' should have 'commands' as the (only) top-level node." >&2
    echo "It currently has $toplevel_nodes_count top-level nodes." >&2
    echo "$commands_nodes_count of which are titled 'commands'." >&2
    return 1
  fi

  # Check if 'commands' has an equal number of 'alias' and 'command' keys
  local size_of_commands_array="$(yq '.commands | length' "$file")"
  local num_of_aliases="$(yq '.commands | map(select(has("alias"))) | length' "$file")"
  local num_of_command="$(yq '.commands | map(select(has("command"))) | length' "$file")"
  if [[ "$size_of_commands_array" -ne "$num_of_aliases" || "$size_of_commands_array" -ne "$num_of_command" ]]; then
    echo "Format Error: '$file' should have 'alias' and 'command' for each command." >&2
    echo "It currently has $size_of_commands_array commands." >&2
    echo "  $num_of_aliases of which have a key 'alias'." >&2
    echo "  $num_of_command of which have a key 'command'." >&2
    return 1
  fi

  if [[ "$size_of_commands_array" -eq 0 ]]; then
    return 0
  fi

  # Check if all 'alias' have no newlines
  local num_of_aliases_with_newlines="$(yq '.commands | map(select(.alias | contains("\n"))) | length' "$file")"
  if [[ "$num_of_aliases_with_newlines" -gt 0 ]]; then
    echo "Format Error: '$file' should not have newlines in aliases." >&2
    echo "It currently has $num_of_aliases_with_newlines aliases with newlines." >&2
    return 1
  fi

  # Check if all 'alias' are unique
  local aliases="$(yq '.commands[].alias' "$file")"
  local unique_aliases="$(echo "$aliases" | sort | uniq)"
  local num_of_unique_aliases="$(echo "$unique_aliases" | wc -l)"
  if [[ "$num_of_aliases" -ne "$num_of_unique_aliases" ]]; then
    echo "Format Error: '$file' should have unique aliases." >&2
    echo "It currently has $num_of_aliases aliases, but there are only $num_of_unique_aliases unique names." >&2
    echo "The following aliases are duplicated:" >&2
    diff --changed-group-format='%<' --unchanged-group-format='' <(echo "$aliases" | sort) <(echo "$unique_aliases" | sort) >&2

    return 1
  fi

  # Check if all 'command' are not empty
  local num_of_empty_commands="$(yq '.commands | map(select(.command | test("^\\s*$"))) | length' "$file")"
  if [[ "$num_of_empty_commands" -gt 0 ]]; then
    echo "Format Error: '$file' should not have empty 'command' keys." >&2
    echo "It currently has $num_of_empty_commands empty 'command' keys." >&2
    return 1
  fi
}

validate_format_of_files() {
  local global_file="$PLS_GLOBAL"
  local local_file=$(get_closest_file "$PWD" "$PLS_FILENAME")

  if [[ -f "$global_file" ]]; then
    validate_format_of_file "$global_file"
  fi

  if [[ -f "$local_file" ]]; then
    validate_format_of_file "$local_file"
  fi
}

# src/lib/validations/validate_is_destination.sh
validate_is_destination() {
  local arg="$1"
  [ "$arg" != "g" ] && [ "$arg" != "l" ] && [ "$arg" != "h" ] && [ "$arg" != "global" ] && [ "$arg" != "local" ] && [ "$arg" != "here" ] && echo "Error: Invalid argument. Must be one of [ g, global, l, local, h, here ]"
}

# src/lib/validations/validate_is_only_operation.sh
validate_is_only_operation() {
  flag_add="${args[--add]}"
  flag_delete="${args[--delete]}"
  flag_list="${args[--list]}"
  is_only_operation "$flag_add" "$flag_delete" "$flag_list"

}

is_only_operation() {
  flag_add="$1"
  flag_delete="$2"
  flag_list="$3"

  num_operations=0
  if [ -n "$flag_add" ]; then
    num_operations=$((num_operations + 1))
  fi
  if [ -n "$flag_delete" ]; then
    num_operations=$((num_operations + 1))
  fi
  if [ -n "$flag_list" ]; then
    num_operations=$((num_operations + 1))
  fi

  if [ "$num_operations" -eq 0 ]; then
    echo "No operation flag supplied."
    return
  fi

  if [ "$num_operations" -ne 1 ]; then
    echo "Can only use one operation flag (--add, --delete, --list) at a time."
  fi
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/workers/add_alias.sh
add_alias() {

  alias="${args[alias]}"
  command="${args[--command]}"
  scope="${args[--scope]}"

  target_file="$(scope_to_path "$scope")"

  if [[ -z "$target_file" && ("$scope" == "local" || "$scope" == "l") ]]; then
    target_file="$(realpath .)/$PLS_FILENAME"

  fi

  # Create file if it does not exist
  if [ ! -f "$target_file" ]; then
    echo "commands:" > "$target_file"
  fi

  # If alias already exists in file, --force flag must be used
  num_occurances_of_alias="$(yq e ".commands | map(select(.alias == \"$alias\")) | length" "$target_file")"
  if [[ $num_occurances_of_alias -eq 1 ]]; then
    if [ ! "${args[--force]}" ]; then
      echo "Error: Alias '$alias' already exists in file '$target_file'. Use --force to overwrite." >&2
      exit 1
    fi
    # Remove the old alias
    delete_entry_from_file "$alias" "$target_file"
  fi

  # Add alias:command entry to file
  add_entry_to_file "$alias" "$command" "$target_file"
}

# src/lib/workers/delete_alias.sh
delete_alias() {
  alias="${args[alias]}"
  scope="${args[--scope]}"

  target_file="$(scope_to_path "$scope")"

  if [[ -z "$target_file" ]]; then
    echo "Error: Can not delete from local file as it does exist here or in any parent." >&2
    exit 1
  fi

  delete_entry_from_file "$alias" "$target_file"
}

# src/lib/workers/execute_alias.sh
execute_alias() {
  local alias="${1}"

  local result=$(query_command "$alias" 1)

  # command is all but last line
  local command=$(echo "$result" | head -n -1)
  # found_in is the last line
  local found_in=$(echo "$result" | tail -n 1)

  # If no command found, exit
  if [ -z "$command" ]; then
    echo "Alias '$alias' was not found."
    exit 1
  fi

  prompt_to_continue() {
      if [[ "$is_cached" == "true" ]]; then
        echo "This command is already cached."
      fi
      echo

      echo "$command"
      echo
      read -p "Are you sure you want to invoke the above command? [y/n] " -n 1 -r
      echo

      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Command was not invoked."
        echo "Exiting..."
        exit 1
      fi
  }

  if [ "${args[--print]}" ]; then
    echo "$command"
    return
  fi

  if exists_in_cache "$found_in" "$alias" "$command"; then
      if [[ "$PLS_ALWAYS_VERIFY" == "true" ]]; then
        prompt_to_continue
      fi

  elif [[ "$PLS_ENABLE_CACHE_CHECK" == "true" || "$PLS_ALWAYS_VERIFY" == "true" ]]; then
      echo "Alias '$alias' was found in '$found_in', but this command seems new."
      prompt_to_continue
  fi

  command_args="${args[command_args]}"
  # Create a temporary function
  exec_alias_command() {

      eval "$command"
  }

  # Execute the function with the arguments
  exec_alias_command $command_args

  add_to_cache "$found_in" "$alias" "$command"
}

# src/lib/workers/list_aliases.sh
list_aliases() {
  local verbose="${args[--print]}"
  local flag_scope="${args[--scope]}"

  local local_file="$(get_closest_file "$PWD" "$PLS_FILENAME")"
  local global_file="$PLS_GLOBAL"

  print_aliases() {
    local file="$1"
    local should_print_command="$2"

    if [[ ! -f "$file" || "$(yq e '.commands | length' "$file")" -eq 0 ]]; then
      echo "No aliases found."
      return
    fi
    local alias_query='.commands | sort_by(.alias) | .[] | .alias'
    local command_query='.commands | sort_by(.alias) | .[] | .alias + "\n" + (.command | split("\n") | map(select(. != "") | "   " + .) | join("\n"))'
    yq e "$([[ "$should_print_command" ]] && echo "$command_query" || echo "$alias_query")" "$file"
  }

  if [ "$flag_scope" == "a" ] || [ "$flag_scope" == "all" ]; then
    echo "--- Global Aliases ---"
    print_aliases "$global_file" "$verbose"
    echo "--- Local Aliases ---"
    print_aliases "$local_file" "$verbose"
  elif [ "$flag_scope" == "g" ] || [ "$flag_scope" == "global" ]; then
    print_aliases "$global_file" "$verbose"
  elif [ "$flag_scope" == "l" ] || [ "$flag_scope" == "local" ]; then
    print_aliases "$local_file" "$verbose"
  elif [ "$flag_scope" == "h" ] || [ "$flag_scope" == "here" ]; then
    echo "Error: Invalid argument. Must be one of [ g, global, l, local, a, all ]" >&2
    exit 1
  else

    local temp_combined_file="$(mktemp)"
    echo "$(merge_pls_files "$global_file" "$local_file")" > "$temp_combined_file"
    print_aliases "$temp_combined_file" "$verbose"
    rm "$temp_combined_file"
  fi
}

# src/lib/workers/pick_and_execute_alias.sh
pick_and_execute_alias() {
  current_list="$(list_aliases)"

  if [[ "$current_list" == "No aliases found." ]]; then
    echo "No aliases found."
    exit 0
  fi

  # if $PLS_ENABLE_FZF is true, and fzf is installed
  if [[ "$PLS_ENABLE_FZF" = true ]] && command -v fzf >/dev/null 2>&1; then
    picked_alias="$(echo "$current_list" | fzf --height 40% --reverse --prompt="Enter alias: ")"
    # Remove ' *' from the end of the alias if it exists
  else
    # print the list with
    # 1 | content
    echo "$current_list" | awk '{print NR " | " $0}'
    read -p "Enter alias (or n): " input
    if [[ "$input" =~ ^[0-9]+$ && "$input" -gt 0 ]]; then
      # Get alias from line number
      picked_alias="$(echo "$current_list" | sed -n "${input}p")"
    else
      # actually entered an alias instead of a number

      picked_alias="$input"
    fi
  fi
  picked_alias="${picked_alias% \*}"
  execute_alias "$picked_alias"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        pls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PLS_RC="${PLS_RC:-$HOME/.config/pls/.plsrc}"

  env_var_names+=("PLS_RC")

  # :command.dependencies_filter
  if command -v yq >/dev/null 2>&1; then
    deps['yaml_parser']="$(command -v yq | head -n1)"
  else
    printf "missing dependency: yaml_parser\n" >&2
    printf "%s\n" "See https://github.com/mikefarah/yq for installation instructions." >&2
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --add | -a)

        # :flag.case_no_arg
        args['--add']=1
        shift
        ;;

      # :flag.case
      --delete | -d)

        # :flag.case_no_arg
        args['--delete']=1
        shift
        ;;

      # :flag.case
      --list | -l)

        # :flag.case_no_arg
        args['--list']=1
        shift
        ;;

      # :flag.case
      --command | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--command']="$2"
          shift
          shift
        else
          printf "%s\n" "--command requires an argument: --command, -c COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --print | -p)

        # :flag.case_no_arg
        args['--print']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --clear-cache)

        # :flag.case_no_arg
        args['--clear-cache']=1
        shift
        ;;

      # :flag.case
      --this-does-nothing)

        # :flag.case_no_arg
        args['--this-does-nothing']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable
        # :argument.case_repeatable
        escaped="$(printf '%q' "$1")"
        if [[ -z ${args['alias']+x} ]]; then
          args['alias']="$1"

        # :argument.case_repeatable
        elif [[ -z ${args['command_args']+x} ]]; then
          args['command_args']="$escaped"
        else
          args['command_args']="${args['command_args']} $escaped"

        fi
        shift

        ;;

    esac
  done

  # :command.needy_flags_filter
  # :flag.needs
  if [[ -n ${args['--add']+x} ]]; then
    for need in --command --scope; do
      if [[ -z "${args[$need]:-}" ]]; then
        printf "%s\n" "--add needs $need" >&2
        exit 1
      fi
    done
  fi

  # :flag.needs
  if [[ -n ${args['--delete']+x} ]] && [[ -z "${args[--scope]:-}" ]]; then
    printf "%s\n" "--delete needs --scope" >&2
    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['alias'] && -n $(validate_not_empty "${args['alias']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "ALIAS" "$(validate_not_empty "${args['alias']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--add'] && -n $(validate_is_only_operation "${args['--add']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--add, -a" "$(validate_is_only_operation "${args['--add']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--delete'] && -n $(validate_is_only_operation "${args['--delete']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--delete, -d" "$(validate_is_only_operation "${args['--delete']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--list'] && -n $(validate_is_only_operation "${args['--list']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--list, -l" "$(validate_is_only_operation "${args['--list']:-}")" >&2
    exit 1
  fi

  # :flag.validations
  if [[ -v args['--command'] && -n $(validate_not_empty "${args['--command']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--command, -c COMMAND" "$(validate_not_empty "${args['--command']:-}")" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ ${args['--scope']:-} ]] && [[ ! ${args['--scope']:-} =~ ^(g|global|l|local|h|here|a|all)$ ]]; then
    printf "%s\n" "--scope must be one of: g, global, l, local, h, here, a, all" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  # Create the PLS_DIR if it does not exist.
  if [ ! -d $(dirname "$PLS_RC") ]; then
      mkdir -p "$(dirname "$PLS_RC")"
  fi

  if [ ! -f "$PLS_RC" ]; then
    echo '
  # The name of the data file in which your aliases live.
  # It is not recommended to change this value for consistency sake, but you can if you feel the need to do so.
  PLS_FILENAME=.pls.yml

  # The path to the global pls file (contains aliases that are available in all directories).

  PLS_GLOBAL=$HOME/$PLS_FILENAME

  # The path to the directory used by pls for storing internal files, such as the command cache.

  # It is not recommended to set this to a directory in /tmp as this may break caching across reboots.

  PLS_DIR=$HOME/.local/share/pls

  # Enable or disable cache checking, which prevents you from unexpectedly running the wrong command.

  # Setting this to false turns off the verification warning that appears when you run an uncached command.
  # This is not recommended, especially not on sensitive systems.

  # This setting is overridden by 'pls_always_cache_check'.
  PLS_ENABLE_CACHE_CHECK=true

  # This will always prompt you to confirm every command before running it, even if it is already cached.

  # Does not assure that the command is safe, but does give you a chance to review it. This setting overrides 'pls_enable_cache_check'.
  PLS_ALWAYS_VERIFY=false

  # Enable or disable the use of fzf for interactive selection. Note that this is only relevant for the 'pick_alias' command. If fzf is not installed, th
  PLS_ENABLE_FZF=true
  ' > $PLS_RC
  fi

  source $PLS_RC

  mkdir -p $PLS_DIR
  if [ ! -d $PLS_DIR ]; then
      echo "Failed to create directory $PLS_DIR"

      exit 1
  fi

  # Ensure yq is installed and is at least version v4.44.2
  min_version="v4.44.2"
  actual_version="$(yq --version | awk '{print $NF}')"
  if ! check_version "$name" "$actual_version" "$min_version"; then
    echo "Error: Your yq version $actual_version is older than $min_version . Please upgrade it to use pls" <&2
    exit 1
  fi

  # Validate syntax of pls files
  validate_format_of_files

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export PLS_RC="${PLS_RC:-$HOME/.config/pls/.plsrc}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
